###  路径和

####  题目（简单-112）

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例: 
给定如下二叉树，以及目标和 sum = 22，

```java
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```

返回 `true`, 因为存在目标和为 22 的根节点到叶子节点的路径 `5->4->11->2`。

####  思考

标准的深度优先搜索算法，这里只需要判断是否有对应的节点和上面的路径和是给定的值就好，不需要进行更多的 对路径的存取。

#### 代码

首先是判断是否是根节点，然后再判断路径的具体和信息。

```java
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null)
            return  false;
        if(root.left == null && root.right == null && sum ==root.val){
                return  true;
        }
        return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);
    }
```

###  路径和II

####  题目（中等-113）

给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

说明: 叶子节点是指没有子节点的节点。

示例:
给定如下二叉树，以及目标和 sum = 22

```java
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
```

返回：

```java
[
   [5,4,11,2],
   [5,8,4,5]
]
```

####  思考

对于这个题目来说，同上面的基本情况是变形题解，要求我们将具体的值放入到`list`中进行返回。还是深度优先搜素的思想。

####  代码

```java
 public List<List<Integer>> pathSum(TreeNode root, int sum) {
 List<List<Integer>> lists = new ArrayList<>();
        List<Integer> list = new ArrayList<>();
        dfs(root,sum,lists,list);
        return lists;
    }
    private  static  void dfs(TreeNode root ,int sum,List<List<Integer>> lists,List<Integer> list ){
        if(root == null)
            return;
        list.add(root.val);
        if(root.left == null && root.right == null && sum == root.val)
        {
            lists.add(new ArrayList<>(list));
            /**
            *注意这里的 提起删除重复的元素，是因为在找到了具体的路径之后，就会直接返回，不会删除上一个已经使用过的值，所以需要在返回之前进行删除的处理。
            **/
            list.remove(list.size()-1);
            return;
        }
        dfs(root.left,sum-root.val,lists,list);
        dfs(root.right,sum-root.val,lists,list);
        list.remove(list.size()-1);

    }
```

